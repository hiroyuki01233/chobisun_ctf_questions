#include <iostream>
#include <vector>
#include <cstdint>
#include <chrono>
#include <cstring>

struct VirtualMachine {
    uint32_t registers[4] = {0};
    uint8_t memory[256] = {0};
    uint16_t ip = 0;
    bool zero_flag = false;
};

void run_vm(VirtualMachine& vm, const std::vector<uint8_t>& bytecode) {
    while (true) {
        if (vm.ip >= bytecode.size()) return;
        uint8_t opcode = bytecode[vm.ip++];

        switch (opcode) {
            case 0x01: { // MOV_VAL reg, val
                uint8_t reg_idx = bytecode[vm.ip++];
                uint32_t value = 0;
                memcpy(&value, &bytecode[vm.ip], 4);
                vm.ip += 4;
                vm.registers[reg_idx] = value;
                break;
            }
            case 0x04: { // STORE mem_addr, reg
                uint8_t addr = bytecode[vm.ip++];
                uint8_t reg_idx = bytecode[vm.ip++];
                vm.memory[addr] = static_cast<uint8_t>(vm.registers[reg_idx]);
                break;
            }
            case 0x06: { // SUB reg1, reg2
                uint8_t reg1_idx = bytecode[vm.ip++];
                uint8_t reg2_idx = bytecode[vm.ip++];
                vm.registers[reg1_idx] -= vm.registers[reg2_idx];
                break;
            }
            case 0x07: { // XOR_REG reg1, reg2
                uint8_t reg1_idx = bytecode[vm.ip++];
                uint8_t reg2_idx = bytecode[vm.ip++];
                vm.registers[reg1_idx] ^= vm.registers[reg2_idx];
                break;
            }
            case 0x10: { // CMP_REG reg1, reg2
                uint8_t reg1_idx = bytecode[vm.ip++];
                uint8_t reg2_idx = bytecode[vm.ip++];
                vm.zero_flag = (vm.registers[reg1_idx] == vm.registers[reg2_idx]);
                break;
            }
            case 0x11: { // JNZ address
                uint16_t addr = 0;
                memcpy(&addr, &bytecode[vm.ip], 2);
                vm.ip += 2;
                if (!vm.zero_flag) {
                    vm.ip = addr;
                }
                break;
            }
            case 0x12: { // CMP_VAL reg, val
                uint8_t reg_idx = bytecode[vm.ip++];
                uint32_t value = 0;
                memcpy(&value, &bytecode[vm.ip], 4);
                vm.ip += 4;
                if (vm.registers[reg_idx] > value) {
                    vm.zero_flag = false;
                } else {
                    vm.zero_flag = true;
                }
                break;
            }
            case 0x20: { // GETC reg
                uint8_t reg_idx = bytecode[vm.ip++];
                char c;
                std::cin.get(c);
                vm.registers[reg_idx] = c;
                break;
            }
            case 0x21: { // PUTC reg
                uint8_t reg_idx = bytecode[vm.ip++];
                std::cout << static_cast<char>(vm.registers[reg_idx]);
                break;
            }
            case 0x30: { // GET_TICK reg
                uint8_t reg_idx = bytecode[vm.ip++];
                auto now = std::chrono::steady_clock::now();
                auto duration = now.time_since_epoch();
                auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count();
                vm.registers[reg_idx] = ms;
                break;
            }
            case 0xFF: { // HALT
                return;
            }
            default:
                return;
        }
    }
}

const std::vector<uint8_t> challenge_bytecode = 
{
    0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x00,

    0x20, 0x01, 0x01, 0x02, 0x43, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x4F, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x52, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x45, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x2D, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x30, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x42, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x2D, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x43, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x4F, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x4D, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x50, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x4C, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x45, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x54, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01, 0x01, 0x02, 0x45, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x11, 0x91, 0x02,
    0x20, 0x01,

    0x30, 0x01,
    0x06, 0x01, 0x00,
    0x12, 0x01, 0xF4, 0x01, 0x00, 0x00,
    0x11, 0x91, 0x02,

    0x01, 0x00, 0x55, 0x00, 0x00, 0x00,
    0x01, 0x01, 0x37, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01,
    0x01, 0x01, 0x26, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01,

    0x01, 0x01, 0x36, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // c
    0x01, 0x01, 0x21, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // t
    0x01, 0x01, 0x33, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // f
    0x01, 0x01, 0x2E, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // {
    0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // T
    0x01, 0x01, 0x30, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // e
    0x01, 0x01, 0x34, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // a
    0x01, 0x01, 0x27, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // r
    0x01, 0x01, 0x26, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // s
    0x01, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // _
    0x01, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // i
    0x01, 0x01, 0x3B, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // n
    0x01, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // _
    0x01, 0x01, 0x21, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // t
    0x01, 0x01, 0x3D, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // h
    0x01, 0x01, 0x30, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // e
    0x01, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // _
    0x01, 0x01, 0x16, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // C
    0x01, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // o
    0x01, 0x01, 0x31, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // d
    0x01, 0x01, 0x30, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // e
    0x01, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // _
    0x01, 0x01, 0x65, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // 0
    0x01, 0x01, 0x17, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // B
    0x01, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // _
    0x01, 0x01, 0x14, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01, // A
    0x01, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01,
    0x01, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01,
    0x01, 0x01, 0x28, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x21, 0x01,
};

int main() {
    VirtualMachine vm;

    std::cout << "Password: ";
    std::cout.flush();

    run_vm(vm, challenge_bytecode);

    // ★★★ 修正済みの判定ロジック ★★★
    // 失敗した場合(R3が1にセットされる)に「Wrong!」と表示する
    if (vm.registers[3] == 1) {
        std::cout << "\nWrong!" << std::endl;
    } else {
        // 成功した場合はVMがフラグを表示するので、ここでは改行のみ
        std::cout << std::endl;
    }

    return 0;
}